## React_extension
* Chapter 1. setState
	1. setState(stateChange, [callback])------object method
 		1. stateChange is a state change object (this object reflects the state change)
            	2. callback is an optional function that is called after the state has been updated and the interface has been updated (after the render call)
					
	2. setState(updater, [callback])------function method
            	1. updater is a function that returns a stateChange object.
            	2. updater can receive state and props.
            	3. callback is an optional function that is called after the state has been updated and the interface has been updated (after the render call)

	* If the new state does not depend on the original state ===> use the object method
	* If the new state depends on the original state ===> use the function method
	* If you need to get the latest state after the execution of setState(), 
					to get data in the second callback function
* Chapter 2. lazyLoad
```js
	const Login = lazy(()=>import('@/pages/Login'))
	
	<Suspense fallback={<h1>loading.....</h1>}>
        	<Switch>
            		<Route path="/xxx" component={Xxxx}/>
            		<Redirect to="/login"/>
        	</Switch>
    	</Suspense>
```
* Chapter 3. hooks
	* Hook is a new feature/ syntax added in React version 16.8.0
	* It allows you to use state and other React features in function components
	1. State Hook: React.useState()
	2. Effect Hook: React.useEffect()
	3. Ref Hook: React.useRef()
* Chapter 4. Fragment
	* There is no need to have a real DOM root tag
	```
	<Fragment><Fragment>  
	or 
	<></>
	```
* Chapter 5. Context
	* Context is designed to share data that can be considered “global” for a tree of React components, such as the current authenticated user, theme, or preferred language
	* component communication method, often used between "ancestor component" and "descendant component"

* Chapter 6. optimize
	* As soon as setState() is executed, the component will be re-rendered() even if the state data is not changed.
	* Only if the current component re-render(), the child component will be render automatically  ==> inefficient

	> because The shouldComponentUpdate() in a component always returns true


	>  Re-render() only when the component's state or props data has changed

	* Approach 1: 
		
	> shouldComponentUpdate() method Compare old and new state or props data, return true if there is a change, false if not
	* Approach 2:  
	> Use PureComponent
 
	#### Attention: Do not modify the state data directly, but generate new data
* Chapter 7. renderProps

	#### children props
	```js
		<A>
	  	<B>xxxx</B>
		</A>
		{this.props.children}
		If component B needs the data in component A, ==> it cannot be done 
	```
	#### render props

	* parent component: <A render={(data) => <C data={data}></C>}></A>
	* A component: {this.props.render(state data)}
	* C component: display the data from A component  {this.props.data} 
* Chapter 8. ErrorBoundary
	* Error boundaries: used to catch errors in child components and render out alternate pages
	* only catch errors generated by the life cycle
	* Cannot catch errors generated by its own components and errors generated by other components in composite events, timers

	```js
	// identifier
	state = {
		hasError:'' 
	}
	// lifecycle function that triggers once a backend component reports an error
	static getDerivedStateFromError(error) {
    	console.log(error);
		// Triggered before render
    	// returns the new state
    	return {
        	hasError: true,
    	};
	}

	componentDidCatch(error, info) {
    	// errors. Send requests to the backend
    	console.log(error, info);
	}
	```

